//=============================================================================================================//// Project: Directional Image Analysis - OrientationJ plugins// // Author: Daniel Sage// // Organization: Biomedical Imaging Group (BIG)// Ecole Polytechnique Federale de Lausanne (EPFL), Lausanne, Switzerland//// Information: // OrientationJ: http://bigwww.epfl.ch/demo/orientation/// MonogenicJ: http://bigwww.epfl.ch/demo/monogenic///  // Reference on methods and plugins// Z. Püspöki, M. Storath, D. Sage, M. Unser// Transforms and Operators for Directional Bioimage Analysis: A Survey // Advances in Anatomy, Embryology and Cell Biology, vol. 219, Focus on Bio-Image Informatics // Springer International Publishing, ch. 33, 2016.////// Reference the application measure of coherency// R. Rezakhaniha, A. Agianniotis, J.T.C. Schrauwen, A. Griffa, D. Sage, // C.V.C. Bouten, F.N. van de Vosse, M. Unser, N. Stergiopulos// Experimental Investigation of Collagen Waviness and Orientation in the Arterial Adventitia // Using Confocal Laser Scanning Microscopy// Biomechanics and Modeling in Mechanobiology, vol. 11, no. 3-4, 2012.// Reference the application direction of orientation// E. Fonck, G.G. Feigl, J. Fasel, D. Sage, M. Unser, D.A. Ruefenacht, N. Stergiopulos // Effect of Aging on Elastin Functionality in Human Cerebral Arteries// Stroke, vol. 40, no. 7, 2009.//// Conditions of use: You are free to use this software for research or// educational purposes. In addition, we expect you to include adequate// citations and acknowledgments whenever you present or publish results that// are based on it.////=============================================================================================================package orientation;import orientation.imageware.Builder;import orientation.imageware.ImageWare;public class CubicSpline {	public static double getInterpolatedPixelCubicSpline(ImageWare coef, double x, double y, int scale) {		double arr[][] = new double[4][4];		int	i = (int)Math.floor(x);		int	j = (int)Math.floor(y);		coef.getNeighborhoodXY(i+1, j+1, scale, arr, ImageWare.MIRROR);		double v = getSampleCubicSpline(x-i, y-j, arr);		return v;	}		/**	* Returns a interpolated pixel using cubic interpolation.	*	* Textbook version of 2D cubic spline interpolator. 	* Note: this routine can be coded more efficiently.	*/	static public double getSampleCubicSpline(double x, double y, double neighbor[][]) {		double xw[] = getCubicSpline(x);		double yw[] = getCubicSpline(y);		double sum = 0.0;		for (int j=0; j<4; j++) {			for (int i=0; i<4; i++) {				sum = sum +  neighbor[i][j] * xw[i] *  yw[j];			}		}		return sum;	}	/**	* Computes the cubic spline basis function at a position t.	*	* @param	t argument between 0 and 1.	* @return	4 sampled values of the cubic B-spline 	*			(B3[t+1], B3[t], B3[t-1], B3[t-2]).	*/		static public double[] getCubicSpline(double t) {		double v[] = new double[4];				if (t < 0.0 || t > 1.0) {			throw new ArrayStoreException(					"Argument t for cubic B-spline outside of expected range."); 		}				double t1 = 1.0 - t;		double t2 = t * t;		v[0] = (t1 * t1 * t1) / 6.0;		v[1] = (2.0 / 3.0) + 0.5 * t2 * (t-2);		v[3] = (t2 * t) / 6.0;		v[2] = 1.0 - v[3] - v[1] - v[0];		return v;	}	/**	* Computes cubic spline coefficients of an image.	*/	static public ImageWare computeCubicSplineCoeffients(ImageWare input) {		int nx = input.getWidth();		int ny = input.getHeight();				ImageWare output = Builder.create(nx, ny, 1, ImageWare.FLOAT);		double	c0 = 6.0;		double	a = Math.sqrt(3.0) - 2.0;							double rowin[]  = new double[nx];		double rowout[]  = new double[nx];		for (int y=0; y<ny; y++) {			input.getX(0, y, 0, rowin);			doSymmetricalExponentialFilter(rowin, rowout, c0, a);			output.putX(0, y, 0, rowout);		}		double colin[]  = new double[ny];		double colout[]  = new double[ny];		for (int x=0; x<nx; x++) {			output.getY(x, 0, 0, colin);			doSymmetricalExponentialFilter(colin, colout, c0, a);			output.putY(x, 0, 0, colout);		}		return output;	}	/**	* Performs the 1D symmetrical exponential filtering.	*/	static public void doSymmetricalExponentialFilter(double s[], double c[], double c0, double a) {		int n = s.length;		double cn[]  = new double[n];		double cp[]  = new double[n];				// causal		cp[0] = computeInitialValueCausal(s, a);		for (int k=1; k<n; k++) {			cp[k] = s[k] + a * cp[k-1];		}					// anticausal		cn[n-1] = computeInitialValueAntiCausal(cp, a);				for (int k=n-2; k>=0; k--) {			cn[k] = a * (cn[k+1] - cp[k]);			}					// gain		for (int k=0; k<n; k++) {			c[k] = c0 * cn[k];		}	}	/**	* Returns the initial value for the causal filter using the mirror boundary	* conditions.	*/	static public double computeInitialValueCausal(double signal[], double a) {		double epsilon = 1e-6; // desired level of precision		int k0 = (int)Math.ceil(Math.log(epsilon)/Math.log(Math.abs(a)));		double polek = a;		double v = signal[0];				for (int k=1; k<k0; k++) {			v = v + polek * signal[k];			polek = polek * a;		}		return v;	}	/**	* Returns the initial value for the anti-causal filter using the mirror boundary	* conditions.	*/	static public double computeInitialValueAntiCausal(double signal[], double a) {		int n = signal.length;		double v = (a / (a * a - 1.0)) * (signal[n-1] + a * signal[n-2]);		return v;	}}